/*
 * This source file was generated by the Gradle 'init' task and then extended.
 */
package org.example

import java.security.MessageDigest

// =====================
// Blockchain Components
// =====================

data class Transaction(val from: String, val to: String, val amount: Double)

data class Block(
    val index: Int,
    val previousHash: String,
    val timestamp: Long,
    val transactions: List<Transaction>,
    var nonce: Int = 0
) {
    var hash: String = calculateHash()

    fun calculateHash(): String {
        val input = "$index$previousHash$timestamp$transactions$nonce"
        return input.sha256()
    }

    fun mineBlock(difficulty: Int) {
        val target = "0".repeat(difficulty)
        while (!hash.startsWith(target)) {
            nonce++
            hash = calculateHash()
        }
        println("Block mined: $hash")
    }
}

fun String.sha256(): String {
    val bytes = this.toByteArray()
    val md = MessageDigest.getInstance("SHA-256")
    val digest = md.digest(bytes)
    return digest.fold("") { str, it -> str + "%02x".format(it) }
}

class Blockchain(private val difficulty: Int = 4) {
    val chain: MutableList<Block> = mutableListOf()
    val pendingTransactions: MutableList<Transaction> = mutableListOf()
    private val miningReward: Double = 50.0

    init {
        chain.add(createGenesisBlock())
    }

    private fun createGenesisBlock(): Block {
        // Genesis block with a dummy transaction.
        return Block(0, "0", System.currentTimeMillis(), listOf(Transaction("0", "Genesis", 0.0)))
    }

    fun getLatestBlock(): Block = chain.last()

    fun addTransaction(transaction: Transaction) {
        // In a real blockchain, you would include validations (e.g., digital signatures, balance checks).
        pendingTransactions.add(transaction)
    }

    fun minePendingTransactions(miningRewardAddress: String) {
        val block = Block(
            index = chain.size,
            previousHash = getLatestBlock().hash,
            timestamp = System.currentTimeMillis(),
            transactions = pendingTransactions.toList()
        )
        block.mineBlock(difficulty)
        chain.add(block)
        println("Block successfully mined and added to the chain!")

        // Reward the miner by adding a new transaction.
        pendingTransactions.clear()
        pendingTransactions.add(Transaction("System", miningRewardAddress, miningReward))
    }

    fun isChainValid(): Boolean {
        for (i in 1 until chain.size) {
            val current = chain[i]
            val previous = chain[i - 1]
            if (current.hash != current.calculateHash()) {
                return false
            }
            if (current.previousHash != previous.hash) {
                return false
            }
        }
        return true
    }
}

// ========================
// Mempool Signet Component
// ========================

class MempoolSignet {

    // Placeholder: Simulate broadcasting a transaction to the Mempool Signet.
    fun broadcastTransaction(transaction: String): String {
        return "Transaction '$transaction' broadcasted to Mempool Signet."
    }
}

// ========================================
// Zero-Knowledge CoinJoin Demonstration
// ========================================

class ZKCoinJoin {

    // Placeholder: Simulate adding participants to the CoinJoin process.
    fun addParticipant(participant: String): String {
        return "Participant $participant added to the CoinJoin."
    }

    // Placeholder: Simulate generating a Zero-Knowledge proof.
    fun generateProof(participant: String): String {
        return "Generated Zero-Knowledge proof for $participant."
    }

    // Placeholder: Simulate the CoinJoin process.
    fun performCoinJoin(): String {
        return "CoinJoin completed using Zero-Knowledge proofs."
    }

    // Placeholder: Simulate moving coins between two CoinJoin processes.
    fun moveCoinsBetweenCoinjoins(source: String, destination: String, amount: Double): String {
        return "Moved $amount coins from $source CoinJoin to $destination CoinJoin."
    }
}

class App {
    val greeting: String
        get() = "Blockchain and ZK Proof CoinJoin with Mempool Signet"
}

// ================
// Main Application
// ================

fun main() {
    // --- Blockchain Demonstration ---
    println("=== Blockchain Demonstration ===")
    val blockchain = Blockchain(difficulty = 3)  // Set a lower difficulty for quicker mining during tests.

    // Add some transactions.
    blockchain.addTransaction(Transaction("Alice", "Bob", 10.0))
    blockchain.addTransaction(Transaction("Bob", "Charlie", 5.0))

    // Mine the pending transactions.
    blockchain.minePendingTransactions("Miner1")

    // Display the blockchain's validity and its blocks.
    println("Blockchain valid: ${blockchain.isChainValid()}")
    println("Blockchain chain:")
    blockchain.chain.forEach { println(it) }

    // --- Zero-Knowledge CoinJoin & Mempool Signet Demonstration ---
    println("\n=== Zero-Knowledge CoinJoin & Mempool Signet Demonstration ===")
    val zkCoinJoin = ZKCoinJoin()
    val mempoolSignet = MempoolSignet()

    // CoinJoin participant management.
    println(zkCoinJoin.addParticipant("Alice"))
    println(zkCoinJoin.addParticipant("Bob"))

    // Generate Zero-Knowledge proofs for the participants.
    println(zkCoinJoin.generateProof("Alice"))
    println(zkCoinJoin.generateProof("Bob"))

    // Execute the CoinJoin process.
    println(zkCoinJoin.performCoinJoin())

    // Simulate moving coins between two CoinJoin instances.
    println(zkCoinJoin.moveCoinsBetweenCoinjoins("Alice", "Bob", 5.0))

    // Simulate broadcasting a transaction through the Mempool Signet.
    val transaction = "Tx1234: Alice -> Bob, 5 coins"
    println(mempoolSignet.broadcastTransaction(transaction))

    // Display application greeting.
    println(App().greeting)
}
